declare module 'web-server-database/server/logs' {
	export let privateLogs: string[];
	export default function logs(log: string): void;

}
declare module 'web-server-database/webpack.config' {
	 var _default: {
	    devtool: string;
	    entry: any[];
	    output: {
	        publicPath: string;
	        path: string;
	        filename: string;
	    };
	    externals: {
	        'angular': string;
	        '$': string;
	    };
	    resolve: {
	        extensions: string[];
	        modulesDirectories: string[];
	    };
	    plugins: any[];
	    target: string;
	    module: {};
	};
	export default _default;

}
declare module 'web-server-database/App' {
	/// <reference types="express" />
	import * as express from 'express';
	export class APIModule {
	    router: express.Router;
	    name: string;
	}
	export class App {
	    express: express.Application;
	    APIModules: APIModule[];
	    webpackConfig: {
	        devtool: string;
	        entry: any[];
	        output: {
	            publicPath: string;
	            path: string;
	            filename: string;
	        };
	        externals: {
	            'angular': string;
	            '$': string;
	        };
	        resolve: {
	            extensions: string[];
	            modulesDirectories: string[];
	        };
	        plugins: any[];
	        target: string;
	        module: {};
	    };
	    constructor();
	    private middleware();
	    private api();
	    listen(port?: number): void;
	} var _default: App;
	export default _default;

}
declare module 'web-server-database/server/database/QueryRequest' {
	export class QueryRequest {
	    constructor(query_value: string, callback_value: (data: any[]) => any);
	    callback: (data: any) => any;
	    query: string;
	}

}
declare module 'web-server-database/server/databaseConfig' {
	export let defaultConfig: {
	    database: string;
	    host: string;
	    port: number;
	    user: string;
	    password: string;
	    waitForConnections: boolean;
	    connectionLimit: number;
	};
	export function GetDatabaseConfig(): {
	    database: string;
	    host: string;
	    port: number;
	    user: string;
	    password: string;
	    waitForConnections: boolean;
	    connectionLimit: number;
	};

}
declare module 'web-server-database/server/database/Connection' {
	/// <reference types="es6-shim" />
	import { QueryRequest } from 'web-server-database/server/database/QueryRequest';
	export class Connection {
	    static pool: any;
	    static poolActiveConnections: number;
	    requestPool: QueryRequest[];
	    static format(query: string, inserts: string[]): string;
	    static createPoolConnection(): void;
	    static query(query: string): Promise<any>;
	    static executeQueryRequestOnConnection(mysqlCon: any, requestPool: QueryRequest[], finishedCallback: () => any): void;
	    executePool(savedAllCallback: () => any): void;
	}

}
declare module 'web-server-database/server/database/BaseModel' {
	/// <reference types="es6-shim" />
	export function hashString(input: any, _salt: any): Promise<string>;
	export function NewUID(): string;
	export function mapObjectToObject(from: any, to: any, schema?: any): void;
	export abstract class ServerModel {
	    modelType: any;
	    _id: string;
	    existingModel: boolean;
	    constructor(instance: any, modelType: any);
	    presave(): Promise<void>;
	    protected abstract saveScript(modelInstance: any): Promise<string>;
	    save(): Promise<ServerModel>;
	    protected abstract createScript(modelInstance: any): Promise<string>;
	    create(): Promise<ServerModel>;
	    protected abstract removeByIdScript(id: string): Promise<string>;
	    removeById(id: string): Promise<void>;
	    remove(): Promise<void>;
	    protected abstract getOneByIdScript(id: string): Promise<string>;
	    getOneById(id: string): Promise<ServerModel>;
	    protected abstract getAllScript(limit: number, skip: number): Promise<string>;
	    all(limit?: number, skip?: number): Promise<any[]>;
	    protected abstract getCountScript(): Promise<string>;
	    getCount(): Promise<number>;
	}

}
declare module 'web-server-database/server/helper' {
	export function CheckNumberParameter(input: any): number;

}
// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/337587de8c13868283993bfacdcdd1a0f3291e7f/bcrypt-nodejs/index.d.ts
declare module 'bcrypt-nodejs' {
// Type definitions for bcrypt-nodejs
// Project: https://github.com/shaneGirish/bcrypt-nodejs
// Definitions by: David Broder-Rodgers <https://github.com/DavidBR-SW/>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped


/**
 * Generate a salt synchronously
 * @param rounds Number of rounds to process the data for (default - 10)
 * @return Generated salt
 */
export function genSaltSync(rounds?: number): string;

/**
 * Generate a salt asynchronously
 * @param rounds Number of rounds to process the data for (default - 10)
 * @param callback Callback with error and resulting salt, to be fired once the salt has been generated
 */
export function genSalt(rounds: number, callback: (error: Error, result: string) => void): void;

/**
 * Generate a hash synchronously
 * @param data Data to be encrypted
 * @param salt Salt to be used in encryption (default - new salt generated with 10 rounds)
 * @return Generated hash
 */
export function hashSync(data: string, salt?: string): string;

/**
 * Generate a hash asynchronously
 * @param data Data to be encrypted
 * @param salt Salt to be used in encryption
 * @param callback Callback with error and hashed result, to be fired once the data has been encrypted
 */
export function hash(data: string, salt: string, callback: (error: Error, result: string) => void): void;

/**
 * Generate a hash asynchronously
 * @param data Data to be encrypted
 * @param salt Salt to be used in encryption
 * @param progressCallback Callback to be fired multiple times during the hash calculation to signify progress
 * @param callback Callback with error and hashed result, to be fired once the data has been encrypted
 */
export function hash(data: string, salt: string, progressCallback: () => void, callback: (error: Error, result: string) => void): void;

/**
 * Compares data with a hash synchronously
 * @param data Data to be compared
 * @param hash Hash to be compared to
 * @return true if matching, false otherwise
 */
export function compareSync(data: string, hash: string): boolean;

/**
 * Compares data with a hash asynchronously
 * @param data Data to be compared
 * @param hash Hash to be compared to
 * @param callback Callback with error and match result, to be fired once the data has been compared
 */
export function compare(data: string, hash: string, callback: (error: Error, result: boolean) => void): void;

/**
 * Get number of rounds used for hash
 * @param hash Hash from which the number of rounds used should be extracted
 * @return number of rounds used to encrypt a given hash
 */
export function getRounds(hash: string): number;
}
// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/80060c94ef549c077a011977c2b5461bd0fd8947/helmet/index.d.ts
declare module 'helmet' {
// Type definitions for helmet
// Project: https://github.com/helmetjs/helmet
// Definitions by: Cyril Schumacher <https://github.com/cyrilschumacher>, Evan Hahn <https://github.com/EvanHahn>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

import express = require('express');

var helmet: helmet.Helmet;
export = helmet;

namespace helmet {
    export interface IHelmetConfiguration {
        contentSecurityPolicy?: boolean | IHelmetContentSecurityPolicyConfiguration,
        dnsPrefetchControl?: boolean | IHelmetDnsPrefetchControlConfiguration,
        frameguard?: boolean | IHelmetFrameguardConfiguration,
        hidePoweredBy?: boolean | IHelmetHidePoweredByConfiguration,
        hpkp?: boolean | IHelmetHpkpConfiguration,
        hsts?: boolean | IHelmetHstsConfiguration,
        ieNoOpen?: boolean,
        noCache?: boolean,
        noSniff?: boolean,
        xssFilter?: boolean | IHelmetXssFilterConfiguration
    }

    export interface IHelmetContentSecurityPolicyDirectiveFunction {
        (req: express.Request, res: express.Response): string;
    }
    export type HelmetCspDirectiveValue = string | IHelmetContentSecurityPolicyDirectiveFunction;

    export interface IHelmetContentSecurityPolicyDirectives {
        baseUri?: HelmetCspDirectiveValue[],
        childSrc?: HelmetCspDirectiveValue[],
        connectSrc?: HelmetCspDirectiveValue[],
        defaultSrc?: HelmetCspDirectiveValue[],
        fontSrc?: HelmetCspDirectiveValue[],
        formAction?: HelmetCspDirectiveValue[],
        frameAncestors?: HelmetCspDirectiveValue[],
        frameSrc?: HelmetCspDirectiveValue[],
        imgSrc?: HelmetCspDirectiveValue[],
        mediaSrc?: HelmetCspDirectiveValue[],
        objectSrc?: HelmetCspDirectiveValue[],
        pluginTypes?: HelmetCspDirectiveValue[],
        reportUri?: string,
        sandbox?: HelmetCspDirectiveValue[],
        scriptSrc?: HelmetCspDirectiveValue[],
        styleSrc?: HelmetCspDirectiveValue[]
    }

    export interface IHelmetContentSecurityPolicyConfiguration {
        reportOnly?: boolean;
        setAllHeaders?: boolean;
        disableAndroid?: boolean;
        browserSniff?: boolean;
        directives?: IHelmetContentSecurityPolicyDirectives
    }

    export interface IHelmetDnsPrefetchControlConfiguration {
        allow?: boolean;
    }

    export interface IHelmetFrameguardConfiguration {
        action?: string,
        domain?: string
    }

    export interface IHelmetHidePoweredByConfiguration {
        setTo?: string
    }

    export interface IHelmetSetIfFunction {
        (req: express.Request, res: express.Response): boolean;
    }

    export interface IHelmetHpkpConfiguration {
        maxAge: number;
        sha256s: string[];
        includeSubdomains?: boolean;
        reportUri?: string;
        reportOnly?: boolean;
        setIf?: IHelmetSetIfFunction
    }

    export interface IHelmetHstsConfiguration {
        maxAge: number;
        includeSubdomains?: boolean;
        preload?: boolean;
        setIf?: IHelmetSetIfFunction,
        force?: boolean;
    }

    export interface IHelmetXssFilterConfiguration {
        setOnOldIE?: boolean;
    }

    /**
     * @summary Interface for helmet class.
     * @interface
     */
    export interface Helmet {
        /**
         * @summary Constructor.
         * @return {RequestHandler} The Request handler.
         */
        (options?: IHelmetConfiguration): express.RequestHandler;

        /**
         * @summary Set policy around third-party content via headers
         * @param {IHelmetContentSecurityPolicyConfiguration} options The options
         * @return {RequestHandler} The Request handler
         */
        contentSecurityPolicy(options?: IHelmetContentSecurityPolicyConfiguration): express.RequestHandler;

        /**
         * @summary Stop browsers from doing DNS prefetching.
         * @param {IHelmetDnsPrefetchControlConfiguration} options The options
         * @return {RequestHandler} The Request handler
         */
        dnsPrefetchControl(options?: IHelmetDnsPrefetchControlConfiguration): express.RequestHandler;

        /**
         * @summary Prevent clickjacking.
         * @param {IHelmetFrameguardConfiguration} options The options
         * @return {RequestHandler} The Request handler
         */
        frameguard(options?: IHelmetFrameguardConfiguration): express.RequestHandler;

        /**
         * @summary Hide "X-Powered-By" header.
         * @param {IHelmetHidePoweredByConfiguration} options The options
         * @return {RequestHandler} The Request handler.
         */
        hidePoweredBy(options?: IHelmetHidePoweredByConfiguration): express.RequestHandler;

        /**
         * @summary Adds the "Public-Key-Pins" header.
         * @param {IHelmetHpkpConfiguration} options The options
         * @return {RequestHandler} The Request handler.
         */
        hpkp(options?: IHelmetHpkpConfiguration): express.RequestHandler;

        /**
         * @summary Adds the "Strict-Transport-Security" header.
         * @param {IHelmetHstsConfiguration} options The options
         * @return {RequestHandler} The Request handler.
         */
        hsts(options?: IHelmetHstsConfiguration): express.RequestHandler;

        /**
         * @summary Add the "X-Download-Options" header.
         * @return {RequestHandler} The Request handler.
         */
        ieNoOpen(): express.RequestHandler;

        /**
         * @summary Add the "Cache-Control" and "Pragma" headers to stop caching.
         * @return {RequestHandler} The Request handler.
         */
        noCache(options?: Object): express.RequestHandler;

        /**
         * @summary Adds the "X-Content-Type-Options" header.
         * @return {RequestHandler} The Request handler.
         */
        noSniff(): express.RequestHandler;

        /**
         * @summary Mitigate cross-site scripting attacks with the "X-XSS-Protection" header.
         * @param {IHelmetXssFilterConfiguration} options The options
         * @return {RequestHandler} The Request handler.
         */
        xssFilter(options?: IHelmetXssFilterConfiguration): express.RequestHandler;
    }
}
}
// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/90dd89f0a43856d2808f898a9228fdaa237f1e76/mysql/index.d.ts
declare module 'mysql' {
// Type definitions for node-mysql
// Project: https://github.com/felixge/node-mysql
// Definitions by: William Johnston <https://github.com/wjohnsto>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

///<reference types="node" />


import stream = require('stream');

function createConnection(connectionUri: string): IConnection;
function createConnection(config: IConnectionConfig): IConnection;
function createPool(config: IPoolConfig): IPool;
function createPoolCluster(config?: IPoolClusterConfig): IPoolCluster;
function escape(value: any): string;
function format(sql: string): string;
function format(sql: string, values: any[]): string;
function format(sql: string, values: any): string;

interface IMySql {
    createConnection(connectionUri: string): IConnection;
    createConnection(config: IConnectionConfig): IConnection;
    createPool(config: IPoolConfig): IPool;
    createPoolCluster(config?: IPoolClusterConfig): IPoolCluster;
    escape(value: any): string;
    format(sql: string): string;
    format(sql: string, values: any[]): string;
    format(sql: string, values: any): string;
}

interface IConnectionStatic {
    createQuery(sql: string): IQuery;
    createQuery(sql: string, callback: (err: IError, ...args: any[]) => void): IQuery;
    createQuery(sql: string, values: any[]): IQuery;
    createQuery(sql: string, values: any[], callback: (err: IError, ...args: any[]) => void): IQuery;
}

interface IConnection {
    config: IConnectionConfig;

    threadId: number;

    beginTransaction(callback: (err: IError) => void): void;

    connect(): void;
    connect(callback: (err: IError, ...args: any[]) => void): void;
    connect(options: any, callback?: (err: IError, ...args: any[]) => void): void;

    commit(callback: (err: IError) => void): void;

    changeUser(options: IConnectionOptions): void;
    changeUser(options: IConnectionOptions, callback: (err: IError) => void): void;

    query: IQueryFunction;

    end(): void;
    end(callback: (err: IError, ...args: any[]) => void): void;
    end(options: any, callback: (err: IError, ...args: any[]) => void): void;

    destroy(): void;

    pause(): void;

    release(): void;
    resume(): void;

    escape(value: any): string;

    escapeId(value: string): string;
    escapeId(values: string[]): string;

    format(sql: string): string;
    format(sql: string, values: any[]): string;
    format(sql: string, values: any): string;

    on(ev: string, callback: (...args: any[]) => void): IConnection;
    on(ev: 'error', callback: (err: IError) => void): IConnection;

    rollback(callback: () => void): void;
}

interface IPool {
    config: IPoolConfig;

    getConnection(callback: (err: IError, connection: IConnection) => void): void;

    query: IQueryFunction;

    end(): void;
    end(callback: (err: IError, ...args: any[]) => void): void;

    on(ev: string, callback: (...args: any[]) => void): IPool;
    on(ev: 'connection', callback: (connection: IConnection) => void): IPool;
    on(ev: 'error', callback: (err: IError) => void): IPool;
}

interface IPoolCluster {
    config: IPoolClusterConfig;

    add(config: IPoolConfig): void;
    add(group: string, config: IPoolConfig): void;

    end(): void;

    getConnection(callback: (err: IError, connection: IConnection) => void): void;
    getConnection(group: string, callback: (err: IError, connection: IConnection) => void): void;
    getConnection(group: string, selector: string, callback: (err: IError, connection: IConnection) => void): void;

    of(pattern: string): IPool;
    of(pattern: string, selector: string): IPool;

    on(ev: string, callback: (...args: any[]) => void): IPoolCluster;
    on(ev: 'remove', callback: (nodeId: number) => void): IPoolCluster;
    on(ev: 'connection', callback: (connection: IConnection) => void): IPoolCluster;
    on(ev: 'error', callback: (err: IError) => void): IPoolCluster;
}

interface IQuery {
    /**
     * The SQL for a constructed query
     */
    sql: string;

    /**
     * Emits a query packet to start the query
     */
    start(): void;

    /**
     * Determines the packet class to use given the first byte of the packet.
     * 
     * @param firstByte The first byte of the packet
     * @param parser The packet parser
     */
    determinePacket(firstByte: number, parser: any): any;

    /**
     * Creates a Readable stream with the given options
     * 
     * @param options The options for the stream.
     */
    stream(options: IStreamOptions): stream.Readable;

    /**
     * Pipes a stream downstream, providing automatic pause/resume based on the 
     * options sent to the stream.
     * 
     * @param options The options for the stream.
     */
    pipe(callback: (...args: any[]) => void): IQuery;

    on(ev: string, callback: (...args: any[]) => void): IQuery;
    on(ev: 'error', callback: (err: IError) => void): IQuery;
    on(ev: 'fields', callback: (fields: IFieldInfo[], index: number) => void): IQuery;
    on(ev: 'result', callback: (row: any, index: number) => void): IQuery;
    on(ev: 'end', callback: () => void): IQuery;
}

interface IQueryFunction {
    (sql: string): IQuery;
    (sql: string, callback: (err: IError, results?: any, fields?: IFieldInfo[]) => void): IQuery;
    (sql: string, values: any[]): IQuery;
    (sql: string, values: any[], callback: (err: IError, results?: any, fields?: IFieldInfo[]) => void): IQuery;
    (sql: string, values: any): IQuery;
    (sql: string, values: any, callback: (err: IError, results?: any, fields?: IFieldInfo[]) => void): IQuery;
    (options: IQueryOptions): IQuery;
    (options: IQueryOptions, callback: (err: IError, results?: any, fields?: IFieldInfo[]) => void): IQuery;
    (options: IQueryOptions, values: any[]): IQuery;
    (options: IQueryOptions, values: any[], callback: (err: IError, results?: any, fields?: IFieldInfo[]) => void): IQuery;
    (options: IQueryOptions, values: any): IQuery;
    (options: IQueryOptions, values: any, callback: (err: IError, results?: any, fields?: IFieldInfo[]) => void): IQuery;
}

interface IQueryOptions {
    /**
     * The SQL for the query
     */
    sql: string;

    /**
     * Every operation takes an optional inactivity timeout option. This allows you to specify appropriate timeouts for 
     * operations. It is important to note that these timeouts are not part of the MySQL protocol, and rather timeout 
     * operations through the client. This means that when a timeout is reached, the connection it occurred on will be 
     * destroyed and no further operations can be performed.
     */
    timeout?: number;

    /**
     * Either a boolean or string. If true, tables will be nested objects. If string (e.g. '_'), tables will be 
     * nested as tableName_fieldName
     */
    nestTables?: any;

    /**
     * Determines if column values should be converted to native JavaScript types. It is not recommended (and may go away / change in the future) 
     * to disable type casting, but you can currently do so on either the connection or query level. (Default: true)
     * 
     * You can also specify a function (field: any, next: () => void) => {} to do the type casting yourself.
     * 
     * WARNING: YOU MUST INVOKE the parser using one of these three field functions in your custom typeCast callback. They can only be called once.
     * 
     * field.string()
     * field.buffer()
     * field.geometry()
     * 
     * are aliases for
     * 
     * parser.parseLengthCodedString()
     * parser.parseLengthCodedBuffer()
     * parser.parseGeometryValue()
     * 
     * You can find which field function you need to use by looking at: RowDataPacket.prototype._typeCast
     */
    typeCast?: any;
}

interface IStreamOptions {
    /**
     * Sets the max buffer size in objects of a stream
     */
    highWaterMark?: number;

    /**
     * The object mode of the stream (Default: true)
     */
    objectMode?: any;
}

interface IConnectionOptions {
    /**
     * The MySQL user to authenticate as
     */
    user?: string;

    /**
     * The password of that MySQL user
     */
    password?: string;

    /**
     * Name of the database to use for this connection
     */
    database?: string;

    /**
     * The charset for the connection. This is called "collation" in the SQL-level of MySQL (like utf8_general_ci). 
     * If a SQL-level charset is specified (like utf8mb4) then the default collation for that charset is used. 
     * (Default: 'UTF8_GENERAL_CI')
     */
    charset?: string;
}

interface IConnectionConfig extends IConnectionOptions {
    /**
     * The hostname of the database you are connecting to. (Default: localhost)
     */
    host?: string;

    /**
     * The port number to connect to. (Default: 3306)
     */
    port?: number;

    /**
     * The source IP address to use for TCP connection
     */
    localAddress?: string;

    /**
     * The path to a unix domain socket to connect to. When used host and port are ignored
     */
    socketPath?: string;

    /**
     * The timezone used to store local dates. (Default: 'local')
     */
    timezone?: string;

    /**
     * The milliseconds before a timeout occurs during the initial connection to the MySQL server. (Default: 10 seconds)
     */
    connectTimeout?: number;

    /**
     * Stringify objects instead of converting to values. (Default: 'false')
     */
    stringifyObjects?: boolean;

    /**
     * Allow connecting to MySQL instances that ask for the old (insecure) authentication method. (Default: false)
     */
    insecureAuth?: boolean;

    /**
     * Determines if column values should be converted to native JavaScript types. It is not recommended (and may go away / change in the future) 
     * to disable type casting, but you can currently do so on either the connection or query level. (Default: true)
     * 
     * You can also specify a function (field: any, next: () => void) => {} to do the type casting yourself.
     * 
     * WARNING: YOU MUST INVOKE the parser using one of these three field functions in your custom typeCast callback. They can only be called once.
     * 
     * field.string()
     * field.buffer()
     * field.geometry()
     * 
     * are aliases for
     * 
     * parser.parseLengthCodedString()
     * parser.parseLengthCodedBuffer()
     * parser.parseGeometryValue()
     * 
     * You can find which field function you need to use by looking at: RowDataPacket.prototype._typeCast
     */
    typeCast?: any;

    /**
     * A custom query format function
     */
    queryFormat?: (query: string, values: any) => void;

    /**
     * When dealing with big numbers (BIGINT and DECIMAL columns) in the database, you should enable this option 
     * (Default: false)
     */
    supportBigNumbers?: boolean;

    /**
     * Enabling both supportBigNumbers and bigNumberStrings forces big numbers (BIGINT and DECIMAL columns) to be 
     * always returned as JavaScript String objects (Default: false). Enabling supportBigNumbers but leaving 
     * bigNumberStrings disabled will return big numbers as String objects only when they cannot be accurately 
     * represented with [JavaScript Number objects] (http://ecma262-5.com/ELS5_HTML.htm#Section_8.5) 
     * (which happens when they exceed the [-2^53, +2^53] range), otherwise they will be returned as Number objects. 
     * This option is ignored if supportBigNumbers is disabled.
     */
    bigNumberStrings?: boolean;

    /**
     * Force date types (TIMESTAMP, DATETIME, DATE) to be returned as strings rather then inflated into JavaScript Date 
     * objects. (Default: false)
     */
    dateStrings?: boolean;

    /**
     * This will print all incoming and outgoing packets on stdout. 
     * You can also restrict debugging to packet types by passing an array of types (strings) to debug;
     * 
     * (Default: false)
     */
    debug?: any;

    /**
     * Generates stack traces on Error to include call site of library entrance ("long stack traces"). Slight 
     * performance penalty for most calls. (Default: true)
     */
    trace?: boolean;

    /**
     * Allow multiple mysql statements per query. Be careful with this, it exposes you to SQL injection attacks. (Default: false)
     */
    multipleStatements?: boolean;

    /**
     * List of connection flags to use other than the default ones. It is also possible to blacklist default ones
     */
    flags?: string[];

    /**
     * object with ssl parameters or a string containing name of ssl profile
     */
    ssl?: any;
}

interface IPoolConfig extends IConnectionConfig {
    /**
     * The milliseconds before a timeout occurs during the connection acquisition. This is slightly different from connectTimeout, 
     * because acquiring a pool connection does not always involve making a connection. (Default: 10 seconds)
     */
    acquireTimeout?: number;

    /**
     * Determines the pool's action when no connections are available and the limit has been reached. If true, the pool will queue 
     * the connection request and call it when one becomes available. If false, the pool will immediately call back with an error. 
     * (Default: true)
     */
    waitForConnections?: boolean;

    /**
     * The maximum number of connections to create at once. (Default: 10)
     */
    connectionLimit?: number;

    /**
     * The maximum number of connection requests the pool will queue before returning an error from getConnection. If set to 0, there 
     * is no limit to the number of queued connection requests. (Default: 0)
     */
    queueLimit?: number;
}

interface IPoolClusterConfig {
    /**
     * If true, PoolCluster will attempt to reconnect when connection fails. (Default: true)
     */
    canRetry?: boolean;

    /**
     * If connection fails, node's errorCount increases. When errorCount is greater than removeNodeErrorCount, 
     * remove a node in the PoolCluster. (Default: 5)
     */
    removeNodeErrorCount?: number;

    /**
     * If connection fails, specifies the number of milliseconds before another connection attempt will be made.
     * If set to 0, then node will be removed instead and never re-used. (Default: 0)
     */
    restoreNodeTimeout?: number;

    /**
     * The default selector. (Default: RR)
     * RR: Select one alternately. (Round-Robin)
     * RANDOM: Select the node by random function.
     * ORDER: Select the first node available unconditionally.
     */
    defaultSelector?: string;
}

interface ISslCredentials {
    /**
     * A string or buffer holding the PFX or PKCS12 encoded private key, certificate and CA certificates
     */
    pfx?: string;

    /**
     * A string holding the PEM encoded private key
     */
    key?: string;

    /**
     * A string of passphrase for the private key or pfx
     */
    passphrase?: string;

    /**
     * A string holding the PEM encoded certificate
     */
    cert?: string;

    /**
     * Either a string or list of strings of PEM encoded CA certificates to trust.
     */
    ca?: string[];

    /**
     * Either a string or list of strings of PEM encoded CRLs (Certificate Revocation List)
     */
    crl?: string[];

    /**
     * A string describing the ciphers to use or exclude
     */
    ciphers?: string;
}

interface IError extends Error {
    /**
     * Either a MySQL server error (e.g. 'ER_ACCESS_DENIED_ERROR'), 
     * a node.js error (e.g. 'ECONNREFUSED') or an internal error 
     * (e.g. 'PROTOCOL_CONNECTION_LOST').
     */
    code: string;

    /**
     * The error number for the error code
     */
    errno: number;

    /**
     * The sql state marker
     */
    sqlStateMarker?: string;

    /**
     * The sql state
     */
    sqlState?: string;

    /**
     * The field count
     */
    fieldCount?: number;

    /**
     * The stack trace for the error
     */
    stack?: string;

    /**
     * Boolean, indicating if this error is terminal to the connection object.
     */
    fatal: boolean;
}

const enum FieldType {
	DECIMAL    = 0x00, // aka DECIMAL (http://dev.mysql.com/doc/refman/5.0/en/precision-math-decimal-changes.html)
	TINY       = 0x01, // aka TINYINT, 1 byte
	SHORT      = 0x02, // aka SMALLINT, 2 bytes
	LONG       = 0x03, // aka INT, 4 bytes
	FLOAT      = 0x04, // aka FLOAT, 4-8 bytes
	DOUBLE     = 0x05, // aka DOUBLE, 8 bytes
	NULL       = 0x06, // NULL (used for prepared statements, I think)
	TIMESTAMP  = 0x07, // aka TIMESTAMP
	LONGLONG   = 0x08, // aka BIGINT, 8 bytes
	INT24      = 0x09, // aka MEDIUMINT, 3 bytes
	DATE       = 0x0a, // aka DATE
	TIME       = 0x0b, // aka TIME
	DATETIME   = 0x0c, // aka DATETIME
	YEAR       = 0x0d, // aka YEAR, 1 byte (don't ask)
	NEWDATE    = 0x0e, // aka ?
	VARCHAR    = 0x0f, // aka VARCHAR (?)
	BIT        = 0x10, // aka BIT, 1-8 byte
	NEWDECIMAL = 0xf6, // aka DECIMAL
	ENUM       = 0xf7, // aka ENUM
	SET        = 0xf8, // aka SET
	TINY_BLOB  = 0xf9, // aka TINYBLOB, TINYTEXT
	MEDIUM_BLOB = 0xfa, // aka MEDIUMBLOB, MEDIUMTEXT
	LONG_BLOB  = 0xfb, // aka LONGBLOG, LONGTEXT
	BLOB       = 0xfc, // aka BLOB, TEXT
	VAR_STRING = 0xfd, // aka VARCHAR, VARBINARY
	STRING     = 0xfe, // aka CHAR, BINARY
	GEOMETRY   = 0xff // aka GEOMETRY
}

interface IFieldInfo {
	catalog: string;
	db: string;
	table: string;
	orgTable: string;
	name: string;
	orgName: string;
	charsetNr: number;
	length: number;
	/**
	 * @see Types interface
	 */
	type: FieldType;
	flags: number;
	decimals: number;
	default: any;
	zeroFill: boolean;
	protocol41: boolean;

}
}
// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/cd4debea25a280da0808d4ff2ca5a4bdb34bd28b/source-map/index.d.ts
declare module 'source-map' {
// Type definitions for source-map v0.5.6
// Project: https://github.com/mozilla/source-map
// Definitions by: Morten Houston Ludvigsen <https://github.com/MortenHoustonLudvigsen>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

export = SourceMap;

namespace SourceMap {
    interface StartOfSourceMap {
        file?: string;
        sourceRoot?: string;
        skipValidation?: boolean;
    }

    interface RawSourceMap {
        version: number;
        sources: string[];
        names: string[];
        sourceRoot?: string;
        sourcesContent?: string[];
        mappings: string;
        file: string;
    }

    interface Position {
        line: number;
        column: number;
    }

    interface MappedPosition extends Position {
        source: string;
        name?: string;
    }

    interface MappingItem {
        source: string;
        generatedLine: number;
        generatedColumn: number;
        originalLine: number;
        originalColumn: number;
        name: string;
    }

    interface Mapping {
        generated: Position;
        original: Position;
        source: string;
        name?: string;
    }

    interface CodeWithSourceMap {
        code: string;
        map: SourceMapGenerator;
    }

    class SourceMapConsumer {
        public static GENERATED_ORDER: number;
        public static ORIGINAL_ORDER: number;

        constructor(rawSourceMap: RawSourceMap | string);

        public computeColumnSpans(): void;

        public originalPositionFor(generatedPosition: Position): MappedPosition;

        public generatedPositionFor(originalPosition: MappedPosition): Position;

        public allGeneratedPositionsFor(originalPosition: MappedPosition): Position[];

        public hasContentsOfAllSources(): boolean;

        public sourceContentFor(source: string, returnNullOnMissing?: boolean): string;

        public eachMapping(callback: (mapping: MappingItem) => void, context?: any, order?: number): void;
    }

    class SourceMapGenerator {
        constructor(startOfSourceMap?: StartOfSourceMap);

        public static fromSourceMap(sourceMapConsumer: SourceMapConsumer): SourceMapGenerator;

        public addMapping(mapping: Mapping): void;

        public setSourceContent(sourceFile: string, sourceContent: string): void;

        public applySourceMap(sourceMapConsumer: SourceMapConsumer, sourceFile?: string, sourceMapPath?: string): void;

        public toString(): string;

        public toJSON(): RawSourceMap;
    }

    class SourceNode {
        children: SourceNode [];
        sourceContents: any;
        line: number;
        column: number;
        source: string;
        name: string;

        constructor();
        constructor(line: number, column: number, source: string);
        constructor(
            line: number,
            column: number,
            source: string,
            chunks?: (string | SourceNode)[] | SourceNode | string,
            name?: string
        );

        public static fromStringWithSourceMap(
            code: string,
            sourceMapConsumer: SourceMapConsumer,
            relativePath?: string
        ): SourceNode;

        public add(chunk: (string | SourceNode)[] | SourceNode | string): SourceNode;

        public prepend(chunk: (string | SourceNode)[] | SourceNode | string): SourceNode;

        public setSourceContent(sourceFile: string, sourceContent: string): void;

        public walk(fn: (chunk: string, mapping: MappedPosition) => void): void;

        public walkSourceContents(fn: (file: string, content: string) => void): void;

        public join(sep: string): SourceNode;

        public replaceRight(pattern: string, replacement: string): SourceNode;

        public toString(): string;

        public toStringWithSourceMap(startOfSourceMap?: StartOfSourceMap): CodeWithSourceMap;
    }
}
}
// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/05e9c858cf55270a48b1234e613fa9b26da8be23/tapable/index.d.ts
declare module 'tapable' {
// Type definitions for tapable v0.2.5
// Project: http://github.com/webpack/tapable.git
// Definitions by: e-cloud <https://github.com/e-cloud>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

abstract class Tapable {
    private _plugins: {
        [propName: string]: Tapable.Handler[]
    }

    /**
     * Register plugin(s)
     * This acts as the same as on() of EventEmitter, for registering a handler/listener to do something when the
     * signal/event happens.
     *
     * @param names a string or an array of strings to generate the id(group name) of plugins
     * @param handler a function which provides the plugin functionality *
     */
    plugin(names: string, handler: (this: this, ...args: any[]) => void): void;

    plugin(names: string[], handler: (this: this, ...args: any[]) => void): void;

    /**
     * invoke all plugins with this attached.
     * This method is just to "apply" plugins' definition, so that the real event listeners can be registered into
     * registry. Mostly the `apply` method of a plugin is the main place to place extension logic.
     */
    apply(...plugins: (((this: this) => any) | Tapable.Plugin)[]): void;

    /**
     * synchronously applies all registered handlers for target name(event id).
     *
     * The handlers are called with all the rest arguments.
     *
     * @param name - plugin group name
     * @param args
     */
    applyPlugins(name: string, ...args: any[]): void;

    applyPlugins0(name: string): void;

    applyPlugins1(name: string, param: any): void;

    applyPlugins2(name: string, param1: any, param2: any): void;

    /**
     * synchronously applies all registered handlers for target name(event id).
     *
     * The handlers are called with the return value of the previous handler and all the rest arguments.
     *
     * `init` is used for the first handler.
     *
     * return the returned value of the last handler
     */
    applyPluginsWaterfall(name: string, init: any, ...args: any[]): any;

    /**
     * synchronously applies all registered handlers for target name(event id).
     *
     * The handlers are called ONLY with the return value of the previous handler.
     *
     * `init` is used for the first handler.
     *
     * return the returned value of the last handler
     */
    applyPluginsWaterfall0(name: string, init: any): any;

    /**
     * synchronously applies all registered handlers for target name(event id).
     *
     * The handlers are called with all the rest arguments.
     *
     * If a handler returns something !== undefined, that value is returned and no more handlers will be applied.
     */
    applyPluginsBailResult(name: string, ...args: any[]): any;

    /**
     * synchronously applies all registered handlers for target name(event id).
     *
     * The handlers are called with target param
     *
     * If a handler returns something !== undefined, the value is returned and no more handlers are applied.
     *
     * Note: the fundamental difference with `{@link applyPluginsBailResult}`, is that,
     *       `{@link applyPluginsBailResult}` passes the arguments as arguments list for plugins
     *       while `{@link applyPluginsBailResult1}` passes the arguments as single param(any type) for plugins
     */
    applyPluginsBailResult1(name: string, param: any): any;

    /**
     * asynchronously applies all registered handlers for target name(event id).
     *
     * The handlers are called with all the rest arguments
     * and a callback function with the signature (err: Error) => void.
     *
     * The handlers are called in series, one at a time. After all handlers are applied, callback is called.
     *
     * If any handler invokes the (anonymous)callback with error, no more handlers will be called
     * and the real callback is call with that error.
     */
    applyPluginsAsync(name: string, ...args: any[]): void;

    /**
     * same as `applyPluginsAsync`
     * @see applyPluginsAsync
     * @alias Tapable.applyPluginsAsync
     * @param name
     * @param args
     */
    applyPluginsAsyncSeries(name: string, ...args: any[]): void;

    applyPluginsAsyncSeries1(name: string, param: any, callback: Tapable.CallbackFunction): void

    /**
     * asynchronously applies all registered handlers for target name(event id).
     *
     * The handlers are called with all the rest arguments
     * and a callback function with the signature (...params) => void.
     *
     * Handlers must invoke the (anonymous)callback, otherwise the series is cut down and real callback won't be
     * invoked.
     *
     * The order is defined by registration order not by speed of the handler function.
     *
     * If a handler returns something !== undefined, that value is returned and no more handlers will be applied.
     */
    applyPluginsAsyncSeriesBailResult(name: string, ...args: any[]): void;

    /**
     * asynchronously applies all registered handlers for target name(event id).
     *
     * @see applyPluginsAsyncSeriesBailResult
     *
     * Note: the fundamental difference with `{@link applyPluginsAsyncSeriesBailResult}`, is that,
     *       `{@link applyPluginsAsyncSeriesBailResult}` passes the arguments as arguments list for plugins
     *       while `{@link applyPluginsAsyncSeriesBailResult1}` passes the arguments as single param(any type)
     *       and a callback for plugins
     */
    applyPluginsAsyncSeriesBailResult1(name: string, param: any, callback: Tapable.CallbackFunction): void;

    /**
     * Asynchronously applies all registered handlers for target name(event id).
     *
     * The handlers are called with the current value and a callback function with the signature (err: Error,
     * nextValue: any) => void.
     *
     * `init` is used for the first handler. The rest handles are called with the value which previous handler uses
     * to invoke the (anonymous)callback invoked
     *
     * After all handlers are applied, callback is called with the last value.
     *
     * If any handler invokes the (anonymous)callback with error, no more handlers will be called
     * and the real callback is call with that error.
     */
    applyPluginsAsyncWaterfall(name: string, init: any, callback: Tapable.CallbackFunction): void;

    /**
     * applies all registered handlers for target name(event id) in parallel.
     *
     * The handlers are called with all the rest arguments
     * and a callback function with the signature (err?: Error) => void.
     *
     * The callback function is called when all handlers call the callback without err.
     *
     * If any handler invokes the callback with err, callback is invoked with this error and the other handlers are
     * skipped.
     */
    applyPluginsParallel(name: string, ...args: any[]): void;

    /**
     * applies all registered handlers for target name(event id) in parallel.
     *
     * The handlers are called with all the rest arguments
     * and a callback function with the signature (currentResult?: []) => void.
     *
     * Handlers must call the callback.
     *
     * The first result (either error or value) with is not undefined is passed to the callback.
     *
     * The order is defined by registration not by speed of the handler function.
     */
    applyPluginsParallelBailResult(name: string, ...args: any[]): void;

    /**
     * applies all registered handlers for target name(event id) in parallel.
     *
     * @see applyPluginsParallelBailResult
     *
     * Note: the fundamental difference with `{@link applyPluginsParallelBailResult}`, is that,
     *       `{@link applyPluginsParallelBailResult}` passes the arguments as arguments list for plugins
     *       while `{@link applyPluginsParallelBailResult1}` passes the arguments as single param(any type)
     *       and a callback for plugins
     */
    applyPluginsParallelBailResult1(name: string, param: any, callback: Tapable.CallbackFunction): void;

    static mixin(proto: any): void;
}

namespace Tapable {
    interface Handler {
        (...args: any[]): void;
    }

    interface Plugin {
        apply(...args: any[]): void;
    }

    interface CallbackFunction {
        (err?: Error, result?: any, ...args: any[]): void;
    }
}

export = Tapable
}
// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/50387d40462301d54cda62e24d3b2ee46540f24a/uglify-js/index.d.ts
declare module 'uglify-js' {
// Type definitions for UglifyJS 2 v2.6.1
// Project: https://github.com/mishoo/UglifyJS2
// Definitions by: Tanguy Krotoff <https://github.com/tkrotoff>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

/// <reference types="source-map" />


import * as MOZ_SourceMap from 'source-map';

namespace UglifyJS {
    interface Tokenizer {
        /**
         * The type of this token.
         * Can be "num", "string", "regexp", "operator", "punc", "atom", "name", "keyword", "comment1" or "comment2".
         * "comment1" and "comment2" are for single-line, respectively multi-line comments.
         */
        type: string;

        /**
         * The name of the file where this token originated from. Useful when compressing multiple files at once to generate the proper source map.
         */
        file: string;

        /**
         * The "value" of the token.
         * That's additional information and depends on the token type: "num", "string" and "regexp" tokens you get their literal value.
         * - For "operator" you get the operator.
         * - For "punc" it's the punctuation sign (parens, comma, semicolon etc).
         * - For "atom", "name" and "keyword" it's the name of the identifier
         * - For comments it's the body of the comment (excluding the initial "//" and "/*".
         */
        value: string;

        /**
         * The line number of this token in the original code.
         * 1-based index.
         */
        line: number;

        /**
         * The column number of this token in the original code.
         * 0-based index.
         */
        col: number;

        /**
         * Short for "newline before", it's a boolean that tells us whether there was a newline before this node in the original source. It helps for automatic semicolon insertion.
         * For multi-line comments in particular this will be set to true if there either was a newline before this comment, or * * if this comment contains a newline.
         */
        nlb: boolean;

        /**
         * This doesn't apply for comment tokens, but for all other token types it will be an array of comment tokens that were found before.
         */
        comments_before: string[];
    }

    interface AST_Node {
        // The first token of this node
        start: AST_Node;

        // The last token of this node
        end: AST_Node;

        transform(tt: TreeTransformer): AST_Toplevel;
    }

    interface AST_Toplevel extends AST_Node {
        // UglifyJS contains a scope analyzer which figures out variable/function definitions, references etc.
        // You need to call it manually before compression or mangling.
        // The figure_out_scope method is defined only on the AST_Toplevel node.
        figure_out_scope(): void;

        // Get names that are optimized for GZip compression (names will be generated using the most frequent characters first)
        compute_char_frequency(): void;

        mangle_names(): void;

        print(stream: OutputStream): void;

        print_to_string(options?: BeautifierOptions): string;
    }

    interface MinifyOptions {
        spidermonkey?: boolean;
        outSourceMap?: string;
        sourceRoot?: string;
        inSourceMap?: string;
        fromString?: boolean;
        warnings?: boolean;
        mangle?: Object;
        output?: MinifyOutput,
        compress?: Object;
    }

    interface MinifyOutput {
        code: string;
        map: string;
    }

    function minify(files: string | Array<string>, options?: MinifyOptions): MinifyOutput;


    interface ParseOptions {
        // Default is false
        strict?: boolean;

        // Input file name, default is null
        filename?: string;

        // Default is null
        toplevel?: AST_Toplevel;
    }

    /**
     * The parser creates a custom abstract syntax tree given a piece of JavaScript code.
     * Perhaps you should read about the AST first.
     */
    function parse(code: string, options?: ParseOptions): AST_Toplevel;


    interface BeautifierOptions {
        /**
         * Start indentation on every line (only when `beautify`)
         */
        indent_start?: number;

        /**
         * Indentation level (only when `beautify`)
         */
        indent_level?: number;

        /**
         * Quote all keys in object literals?
         */
        quote_keys?: boolean;

        /**
         * Add a space after colon signs?
         */
        space_colon?: boolean;

        /**
         * Output ASCII-safe? (encodes Unicode characters as ASCII)
         */
        ascii_only?: boolean;

        /**
         * Escape "</script"?
         */
        inline_script?: boolean;

        /**
         * Informative maximum line width (for beautified output)
         */
        width?: number;

        /**
         * Maximum line length (for non-beautified output)
         */
        max_line_len?: number;

        /**
         * Output IE-safe code?
         */
        ie_proof?: boolean;

        /**
         * Beautify output?
         */
        beautify?: boolean;

        /**
         * Output a source map
         */
        source_map?: SourceMapOptions;

        /**
         * Use brackets every time?
         */
        bracketize?: boolean;

        /**
         * Output comments?
         */
        comments?: boolean;

        /**
         * Use semicolons to separate statements? (otherwise, newlines)
         */
        semicolons?: boolean;
    }

    interface OutputStream {
        // Return the output so far as a string
        get(): string;
        toString(): string;

        // Insert one indentation string (usually 4 characters).
        // Optionally pass true to indent half the width (I'm using that for case and default lines in switch blocks.
        // If beautify is off, this function does nothing.
        indent(half?: boolean): void;

        // Return the current indentation width (not level; for example if we're in level 2 and indent_level is 4, this method would return 8.
        indentation(): number;

        // return the width of the current line text minus indentation.
        current_width(): number

        // Return true if current_width() is bigger than options.width (assuming options.width is non-null, non-zero).
        should_break(): boolean;

        // If beautification is on, this inserts a newline. Otherwise it does nothing.
        newline(): void;

        // Include the given string into the output, adjusting current_line, current_col and current_pos accordingly.
        print(str: string): void;

        // If beautification is on this always includes a space character.
        // Otherwise it saves a hint somewhere that a space might be needed at current point.
        // The space will go in at the next output but only when absolutely required, for example it will insert the space in return 10 but not in return"stuff".
        space(): void;

        // Inserts a comma, and calls space()  that is, if beautification is on you'll get a space after the comma.
        comma(): void;

        // Inserts a colon, and calls space() if options.space_colon is set.
        colon(): void;

        // Returns the last printed chunk.
        last(): string;

        // If beautification is on it always inserts a semicolon.
        // Otherwise it saves a hint that a semicolon might be needed at current point.
        // The semicolon is inserted when the next output comes in, only if required to not break the JS syntax.
        semicolon(): void;

        // Always inserts a semicolon and clears the hint that a semicolon might be needed.
        force_semicolon(): void;

        // Encodes any non-ASCII characters in string with JavaScript's conventions (using \uCODE).
        to_ascii(str: string): void;

        // Prints an identifier. If options.ascii_only is set, non-ASCII chars will be encoded with JavaScript conventions.
        print_name(name: string): void;

        // Prints a string. It adds quotes automatically.
        // It prefers double-quotes, but will actually count any quotes in the string and will use single-quotes if the output proves to be shorter (depending on how many backslashes it has to insert).
        // It encodes to ASCII if options.ascii_only is set.
        print_string(str: string): void;

        // Returns the width of the next indentation level. For example if current level is 2 and options.indent_level is 4, it'll return 12.
        next_indent(): number;

        // Sets the current indentation to col (column), calls the function and thereafter restores the previous indentation level.
        // If beautification is off it simply calls func.
        with_indent(col: number, func: Function): void;

        // This is used to output blocks in curly brackets.
        // It'll print an open bracket at current point, then call newline() and with the next indentation level it calls your func.
        // Lastly, it'll print an indented closing bracket. As usual, if beautification is off you'll just get {x} where x is whatever func outputs.
        with_block(func: Function): void;

        // Adds parens around the output that your function prints.
        with_parens(func: Function): void;

        // Adds square brackets around the output that your function prints.
        with_square(func: Function): void;

        // If options.source_map is set, this will generate a source mapping between the given token (which should be an AST_Token-like object) and the current line/col.
        // The name is optional; in most cases it will be inferred from the token.
        add_mapping(token: AST_Node, name?: string): void;

        // Returns the option with the given name.
        option(name: string): any;

        // Returns the current line in the output (1-based).
        line(): number;

        // Returns the current column in the output (zero-based).
        col(): number;

        // Push the given node into an internal stack. This is used to keep track of current node's parent(s).
        push_node(node: AST_Node): void;

        // Pops the top of the stack and returns it.
        pop_node(): AST_Node;

        // Returns that internal stack.
        stack(): any;

        // Returns the n-th parent node (where zero means the direct parent).
        parent(n: number): AST_Node;
    }

    /**
     * The code generator is a recursive process of getting back source code from an AST returned by the parser.
     * Every AST node has a print method that takes an OutputStream and dumps the code from that node into it.
     * The stream object supports a lot of options that control the output.
     * You can specify whether you'd like to get human-readable (indented) output, the indentation level, whether you'd like to quote all properties in object literals etc.
     */
    function OutputStream(options?: BeautifierOptions): OutputStream;


    interface SourceMapOptions {
        /**
         * The compressed file name
         */
        file?: string;

        /**
         * The root URL to the original sources
         */
        root?: string;

        /**
         * The input source map.
         * Useful when you compress code that was generated from some other source (possibly other programming language).
         * If you have an input source map, pass it in this argument and UglifyJS will generate a mapping that maps back
         * to the original source (as opposed to the compiled code that you are compressing).
         */
        orig?: Object | JSON;
    }

    interface SourceMap {
        add(source: string, gen_line: number, gen_col: number, orig_line: number, orig_col: number, name?: string): void;
        get(): MOZ_SourceMap.SourceMapGenerator;
        toString(): string;
    }

    /**
     * The output stream keeps track of the current line/column in the output and can trivially generate a source mapping to the original code via Mozilla's source-map library.
     * To use this functionality, you must load this library (it's automatically require-d by UglifyJS in the NodeJS version, but in a browser you must load it yourself)
     * and make it available via the global MOZ_SourceMap variable.
     */
    function SourceMap(options?: SourceMapOptions): SourceMap;


    interface CompressorOptions {
        // Join consecutive statemets with the comma operator
        sequences?: boolean;

        // Optimize property access: a["foo"]  a.foo
        properties?: boolean;

        // Discard unreachable code
        dead_code?: boolean;

        // Discard debugger statements
        drop_debugger?: boolean;

        // Some unsafe optimizations (see below)
        unsafe?: boolean;

        // Optimize if-s and conditional expressions
        conditionals?: boolean;

        // Optimize comparisons
        comparisons?: boolean;

        // Evaluate constant expressions
        evaluate?: boolean;

        // Optimize boolean expressions
        booleans?: boolean;

        // Optimize loops
        loops?: boolean;

        // Drop unused variables/functions
        unused?: boolean;

        // Hoist function declarations
        hoist_funs?: boolean;

        // Hoist variable declarations
        hoist_vars?: boolean;

        // Optimize if-s followed by return/continue
        if_return?: boolean;

        // Join var declarations
        join_vars?: boolean;

        // Try to cascade `right` into `left` in sequences
        cascade?: boolean;

        // Drop side-effect-free statements
        side_effects?: boolean;

        // Warn about potentially dangerous optimizations/code
        warnings?: boolean;

        // Global definitions
        global_defs?: Object;
    }

    /**
     * The compressor is a tree transformer which reduces the code size by applying various optimizations on the AST
     */
    function Compressor(options?: CompressorOptions): AST_Toplevel;


    // TODO
    interface TreeWalker {
    }

    type visitor = (node: AST_Node, descend: Function) => boolean;

    /**
     * UglifyJS provides a TreeWalker object and every node has a walk method that given a walker will apply your visitor to each node in the tree.
     * Your visitor can return a non-falsy value in order to prevent descending the current node.
     */
    function TreeWalker(visitor: visitor): TreeWalker;


    // TODO
    interface TreeTransformer extends TreeWalker {
    }

    /**
     * The tree transformer is a special case of a tree walker.
     * In fact it even inherits from TreeWalker and you can use the same methods, but initialization and visitor protocol are a bit different.
     */
    function TreeTransformer(before: visitor, after: visitor): TreeTransformer;
}

export = UglifyJS;
}
// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/c960430ff9a47bb94ef53ad79fbb759343ea3abb/webpack/index.d.ts
declare module 'webpack' {
// Type definitions for webpack 2.2
// Project: https://github.com/webpack/webpack
// Definitions by: Qubo <https://github.com/tkqubo>, Matt Lewis <https://github.com/mattlewis92>, Benjamin Lim <https://github.com/bumbleblym>, Boris Cherny <https://github.com/bcherny>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

/// <reference types="node" />

import * as UglifyJS from 'uglify-js';
import * as tapable from 'tapable';

namespace webpack {
    interface Configuration {
        context?: string;
        entry?: string | string[] | Entry;
        /** Choose a style of source mapping to enhance the debugging process. These values can affect build and rebuild speed dramatically. */
        devtool?: 'eval' | 'inline-source-map' | 'cheap-eval-source-map' | 'cheap-source-map' | 'cheap-module-eval-source-map' | 'cheap-module-source-map' | 'eval-source-map' | 'source-map' | 'nosources-source-map' | 'hidden-source-map' | 'nosources-source-map' | '@eval' | '@inline-source-map' | '@cheap-eval-source-map' | '@cheap-source-map' | '@cheap-module-eval-source-map' | '@cheap-module-source-map' | '@eval-source-map' | '@source-map' | '@nosources-source-map' | '@hidden-source-map' | '@nosources-source-map' | '#eval' | '#inline-source-map' | '#cheap-eval-source-map' | '#cheap-source-map' | '#cheap-module-eval-source-map' | '#cheap-module-source-map' | '#eval-source-map' | '#source-map' | '#nosources-source-map' | '#hidden-source-map' | '#nosources-source-map' | '#@eval' | '#@inline-source-map' | '#@cheap-eval-source-map' | '#@cheap-source-map' | '#@cheap-module-eval-source-map' | '#@cheap-module-source-map' | '#@eval-source-map' | '#@source-map' | '#@nosources-source-map' | '#@hidden-source-map' | '#@nosources-source-map' | boolean;
        /** Options affecting the output. */
        output?: Output;
        /** Options affecting the normal modules (NormalModuleFactory) */
        module?: Module;
        /** Options affecting the resolving of modules. */
        resolve?: Resolve;
        /** Like resolve but for loaders. */
        resolveLoader?: ResolveLoader;
        /**
         *  Specify dependencies that shouldnt be resolved by webpack, but should become dependencies of the resulting bundle.
         *  The kind of the dependency depends on output.libraryTarget.
         */
        externals?: ExternalsElement | ExternalsElement[];
        /**
         * <ul>
         *   <li>"web" Compile for usage in a browser-like environment (default)</li>
         *   <li>"webworker" Compile as WebWorker</li>
         *   <li>"node" Compile for usage in a node.js-like environment (use require to load chunks)</li>
         *   <li>"async-node" Compile for usage in a node.js-like environment (use fs and vm to load chunks async)</li>
         *   <li>"node-webkit" Compile for usage in webkit, uses jsonp chunk loading but also supports builtin node.js modules plus require(nw.gui) (experimental)</li>
         *   <li>"atom" Compile for usage in electron (formerly known as atom-shell), supports require for modules necessary to run Electron.</li>
         * <ul>
         */
        target?: string;
        /** Report the first error as a hard error instead of tolerating it. */
        bail?: boolean;
        /** Capture timing information for each module. */
        profile?: boolean;
        /** Cache generated modules and chunks to improve performance for multiple incremental builds. */
        cache?: boolean | any;
        /** Enter watch mode, which rebuilds on file change. */
        watch?: boolean;
        watchOptions?: WatchOptions;
        /** Switch loaders to debug mode. */
        debug?: boolean;
        /** Can be used to configure the behaviour of webpack-dev-server when the webpack config is passed to webpack-dev-server CLI. */
        devServer?: any; // TODO: Type this
        /** Include polyfills or mocks for various node stuff */
        node?: Node;
        /** Set the value of require.amd and define.amd. */
        amd?: { [moduleName: string]: boolean };
        /** Used for recordsInputPath and recordsOutputPath */
        recordsPath?: string;
        /** Load compiler state from a json file. */
        recordsInputPath?: string;
        /** Store compiler state to a json file. */
        recordsOutputPath?: string;
        /** Add additional plugins to the compiler. */
        plugins?: Plugin[];
        /** Stats options for logging  */
        stats?: compiler.StatsToStringOptions;
        /** Performance options */
        performance?: PerformanceOptions;
    }

    interface Entry {
        [name: string]: string | string[];
    }

    interface Output {
        /** The output directory as absolute path (required). */
        path?: string;
        /** The filename of the entry chunk as relative path inside the output.path directory. */
        filename?: string;
        /** The filename of non-entry chunks as relative path inside the output.path directory. */
        chunkFilename?: string;
        /** The filename of the SourceMaps for the JavaScript files. They are inside the output.path directory. */
        sourceMapFilename?: string;
        /** Filename template string of function for the sources array in a generated SourceMap. */
        devtoolModuleFilenameTemplate?: string;
        /** Similar to output.devtoolModuleFilenameTemplate, but used in the case of duplicate module identifiers. */
        devtoolFallbackModuleFilenameTemplate?: string;
        /**
         * Enable line to line mapped mode for all/specified modules.
         * Line to line mapped mode uses a simple SourceMap where each line of the generated source is mapped to the same line of the original source.
         * Its a performance optimization. Only use it if your performance need to be better and you are sure that input lines match which generated lines.
         * true enables it for all modules (not recommended)
         */
        devtoolLineToLine?: boolean;
        /** The filename of the Hot Update Chunks. They are inside the output.path directory. */
        hotUpdateChunkFilename?: string;
        /** The filename of the Hot Update Main File. It is inside the output.path directory. */
        hotUpdateMainFilename?: string;
        /** The output.path from the view of the Javascript / HTML page. */
        publicPath?: string;
        /** The JSONP function used by webpack for asnyc loading of chunks. */
        jsonpFunction?: string;
        /** The JSONP function used by webpack for async loading of hot update chunks. */
        hotUpdateFunction?: string;
        /** Include comments with information about the modules. */
        pathinfo?: boolean;
        /** If set, export the bundle as library. output.library is the name. */
        library?: string;
        /**
         * Which format to export the library:
         * <ul>
         *   <li>"var" - Export by setting a variable: var Library = xxx (default)</li>
         *   <li>"this" - Export by setting a property of this: this["Library"] = xxx</li>
         *   <li>"commonjs" - Export by setting a property of exports: exports["Library"] = xxx</li>
         *   <li>"commonjs2" - Export by setting module.exports: module.exports = xxx</li>
         *   <li>"amd" - Export to AMD (optionally named)</li>
         *   <li>"umd" - Export to AMD, CommonJS2 or as property in root</li>
         * </ul>
         */
        libraryTarget?: string;
        /** If output.libraryTarget is set to umd and output.library is set, setting this to true will name the AMD module. */
        umdNamedDefine?: boolean;
        /** Prefixes every line of the source in the bundle with this string. */
        sourcePrefix?: string;
        /** This option enables cross-origin loading of chunks. */
        crossOriginLoading?: string | boolean;
    }

    interface BaseModule {
        /** A array of applied pre loaders. */
        preLoaders?: Rule[];
        /** A array of applied post loaders. */
        postLoaders?: Rule[];
        /** A RegExp or an array of RegExps. Dont parse files matching. */
        noParse?: RegExp | RegExp[];
        unknownContextRequest?: string;
        unknownContextRecursive?: boolean;
        unknownContextRegExp?: RegExp;
        unknownContextCritical?: boolean;
        exprContextRequest?: string;
        exprContextRegExp?: RegExp;
        exprContextRecursive?: boolean;
        exprContextCritical?: boolean;
        wrappedContextRegExp?: RegExp;
        wrappedContextRecursive?: boolean;
        wrappedContextCritical?: boolean;
    }
    interface OldModule extends BaseModule {
        /** An array of automatically applied loaders. */
        loaders: Rule[];
    }
    interface NewModule extends BaseModule {
        /** An array of rules applied for modules. */
        rules: Rule[];
    }
    type Module = OldModule | NewModule;

    interface NewResolve {
        /**
         * A list of directories to resolve modules from.
         *
         * Absolute paths will be searched once.
         *
         * If an entry is relative, will be resolved using node's resolution algorithm
         * relative to the requested file.
         *
         * Defaults to `["node_modules"]`
         */
        modules?: string[];

        /**
         * A list of package description files to search for.
         *
         * Defaults to `["package.json"]`
         */
        descriptionFiles?: string[];

        /**
         * A list of fields in a package description object to use for finding
         * the entry point.
         *
         * Defaults to `["browser", "module", "main"]` or `["module", "main"]`,
         * depending on the value of the `target` `Configuration` value.
         */
        mainFields?: string[];

        /**
         * A list of fields in a package description object to try to parse
         * in the same format as the `alias` resolve option.
         *
         * Defaults to `["browser"]` or `[]`, depending on the value of the
         * `target` `Configuration` value.
         *
         * @see alias
         */
        aliasFields?: string[];

        /**
         * A list of file names to search for when requiring directories that
         * don't contain a package description file.
         *
         * Defaults to `["index"]`.
         */
        mainFiles?: string[];

        /**
         * A list of file extensions to try when requesting files.
         *
         * An empty string is considered invalid.
         */
        extensions?: string[];

        /**
         * If true, requires that all requested paths must use an extension
         * from `extensions`.
         */
        enforceExtension?: boolean;

        /**
         * Replace the given module requests with other modules or paths.
         *
         * @see aliasFields
         */
        alias?: { [key: string]: string; };

        /**
         * Whether to use a cache for resolving, or the specific object
         * to use for caching. Sharing objects may be useful when running
         * multiple webpack compilers.
         *
         * Defaults to `true`.
         */
        unsafeCache?: {} | boolean;

        /**
         * A function used to decide whether to cache the given resolve request.
         *
         * Defaults to `() => true`.
         */
        cachePredicate?: (data: { path: string, request: string }) => boolean;
    }

    interface OldResolve {
        /** Replace modules by other modules or paths. */
        alias?: { [key: string]: string; };
        /**
         * The directory (absolute path) that contains your modules.
         * May also be an array of directories.
         * This setting should be used to add individual directories to the search path.
         *
         * @deprecated Replaced by `modules` in webpack 2.
         */
        root?: string | string[];
        /**
         * An array of directory names to be resolved to the current directory as well as its ancestors, and searched for modules.
         * This functions similarly to how node finds node_modules directories.
         * For example, if the value is ["mydir"], webpack will look in ./mydir, ../mydir, ../../mydir, etc.
         *
         * @deprecated Replaced by `modules` in webpack 2.
         */
        modulesDirectories?: string[];
        /**
         * A directory (or array of directories absolute paths),
         * in which webpack should look for modules that werent found in resolve.root or resolve.modulesDirectories.
         *
         * @deprecated Replaced by `modules` in webpack 2.
         */
        fallback?: string | string[];
        /**
         * An array of extensions that should be used to resolve modules.
         * For example, in order to discover CoffeeScript files, your array should contain the string ".coffee".
         */
        extensions?: string[];
        /**
         * Check these fields in the package.json for suitable files.
         *
         * @deprecated Replaced by `mainFields` in webpack 2.
         */
        packageMains?: Array<string | string[]>;

        /**
         * Check this field in the package.json for an object. Key-value-pairs are threaded as aliasing according to this spec
         *
         * @deprecated Replaced by `aliasFields` in webpack 2.
         */
        packageAlias?: Array<string | string[]>;

        /**
         * Enable aggressive but unsafe caching for the resolving of a part of your files.
         * Changes to cached paths may cause failure (in rare cases). An array of RegExps, only a RegExp or true (all files) is expected.
         * If the resolved path matches, itll be cached.
         *
         * @deprecated Split into `unsafeCache` and `cachePredicate` in webpack 2.
         */
        unsafeCache?: RegExp | RegExp[] | boolean;
    }

    type Resolve = OldResolve | NewResolve;

    interface OldResolveLoader extends OldResolve {
        /** It describes alternatives for the module name that are tried.
         * @deprecated Replaced by `moduleExtensions` in webpack 2.
         */
        moduleTemplates?: string[];
    }

    interface NewResolveLoader extends NewResolve {
        /**
         * List of strings to append to a loader's name when trying to resolve it.
         */
        moduleExtensions?: string[];

        enforceModuleExtension?: boolean;
    }

    type ResolveLoader = OldResolveLoader | NewResolveLoader;

    type ExternalsElement = string | RegExp | ExternalsObjectElement | ExternalsFunctionElement;

    interface ExternalsObjectElement {
        [key: string]: boolean | string;
    }

    type ExternalsFunctionElement = (context: any, request: any, callback: (error: any, result: any) => void) => any;

    interface WatchOptions {
        /** Delay the rebuilt after the first change. Value is a time in ms. */
        aggregateTimeout?: number;
        /** For some systems, watching many file systems can result in a lot of CPU or memory usage. It is possible to exclude a huge folder like node_modules. It is also possible to use anymatch patterns. */
        ignored?: RegExp | string;
        /** true: use polling, number: use polling with specified interval */
        poll?: boolean | number;
    }

    interface Node {
        console?: boolean;
        global?: boolean;
        process?: boolean;
        Buffer?: boolean;
        __filename?: boolean | string;
        __dirname?: boolean | string;
        [nodeBuiltin: string]: boolean | string | undefined;
    }

    interface BaseConditionSpec {
        /** The Condition must match. The convention is the provide a string or array of strings here, but it's not enforced. */
        include?: Condition;
        /** The Condition must NOT match. The convention is the provide a string or array of strings here, but it's not enforced. */
        exclude?: Condition;
    }
    interface TestConditionSpec extends BaseConditionSpec {
        /** The Condition must match. The convention is the provide a RegExp or array of RegExps here, but it's not enforced. */
        test: Condition;
    }
    interface AndConditionSpec extends BaseConditionSpec {
        /** All Conditions must match. */
        and: Condition[];
    }
    interface OrConditionSpec extends BaseConditionSpec {
        /** Any Condition must match. */
        or: Condition[];
    }
    interface NotConditionSpec extends BaseConditionSpec {
        /** The Condition must NOT match. */
        not: Condition;
    }
    type ConditionSpec = TestConditionSpec | OrConditionSpec | AndConditionSpec | NotConditionSpec;

    // tslint:disable-next-line:no-empty-interface
    interface ConditionArray extends Array<Condition> {}
    type Condition = string | RegExp | ((absPath: string) => boolean) | ConditionSpec | ConditionArray;

    interface OldLoader {
        loader: string;
        query?: { [name: string]: any };
    }
    interface NewLoader {
        loader: string;
        options?: { [name: string]: any };
    }
    type Loader = string | OldLoader | NewLoader;

    /**
     * There are direct and delegate rules. Direct Rules need a test, Delegate rules delegate to subrules bringing their own.
     * Direct rules can optionally contain delegate keys (oneOf, rules).
     *
     * These types exist to enforce that a rule has the keys `((loader XOR loaders) AND test) OR oneOf OR rules`
     */
    interface BaseRule {
        /**
         * Specifies the category of the loader. No value means normal loader.
         *
         * There is also an additional category "inlined loader" which are loaders applied inline of the import/require.
         *
         * All loaders are sorted in the order post, inline, normal, pre and used in this order.
         *
         * All normal loaders can be omitted (overridden) by prefixing ! in the request.
         *
         * All normal and pre loaders can be omitted (overridden) by prefixing -! in the request.
         *
         * All normal, post and pre loaders can be omitted (overridden) by prefixing !! in the request.
         *
         * Inline loaders and ! prefixes should not be used as they are non-standard. They may be use by loader generated code.
         */
        enforce?: 'pre' | 'post';
        /** A condition that must be met */
        test?: Condition | Condition[];
        /** A condition that must not be met */
        exclude?: Condition | Condition[];
        /** A condition that must be met */
        include?: Condition | Condition[];
        /** A Condition matched with the resource. */
        resource?: Condition | Condition[];
        /** A condition matched with the issuer */
        issuer?: Condition | Condition[];
        /**
         * An object with parser options. All applied parser options are merged.
         *
         * For each different parser options object a new parser is created and plugins can apply plugins depending on the parser options. Many of the default plugins apply their parser plugins only if a property in the parser options is not set or true.
         */
        parser?: { [optName: string]: any };
        /** An array of Rules that is also used when the Rule matches. */
        rules?: Rule[];
        /** An array of Rules from which only the first matching Rule is used when the Rule matches. */
        oneOf?: Rule[];
    }
    interface BaseDirectRule extends BaseRule {
        /** A condition that must be met */
        test: Condition | Condition[];
    }
    // Direct Rules
    interface BaseSingleLoaderRule extends BaseDirectRule {
        /** Loader name or an object with name and options */
        loader: Loader;
    }
    interface OldLoaderRule extends BaseSingleLoaderRule {
        /**
         * Loader options
         * @deprecated:
         */
        query?: { [name: string]: any };
    }
    interface NewLoaderRule extends BaseSingleLoaderRule {
        options?: { [name: string]: any };
    }
    type LoaderRule = OldLoaderRule | NewLoaderRule;
    interface OldUseRule extends BaseDirectRule {
        /**
         * A array of loaders.
         * @deprecated  use `use` instead
         */
        loaders: string[];
    }
    interface NewUseRule extends BaseDirectRule {
        /** A loader or array of loaders */
        use: Loader | Loader[];
    }
    type UseRule = OldUseRule | NewUseRule;

    // Delegate Rules
    interface RulesRule extends BaseRule {
        /** An array of Rules that is also used when the Rule matches. */
        rules: Rule[];
    }
    interface OneOfRule extends BaseRule {
        oneOf: Rule[];
    }
    type Rule = LoaderRule | UseRule | RulesRule | OneOfRule;

    interface Plugin extends tapable.Plugin {
        apply(thisArg: Webpack, ...args: any[]): void;
    }

    type UglifyCommentFunction = (astNode: any, comment: any) => boolean

    interface UglifyPluginOptions extends UglifyJS.MinifyOptions {
        beautify?: boolean;
        comments?: boolean | RegExp | UglifyCommentFunction;
        sourceMap?: boolean;
        test?: Condition | Condition[];
        include?: Condition | Condition[];
        exclude?: Condition | Condition[];
    }

    interface Webpack {
        (config: Configuration, callback?: compiler.CompilerCallback): compiler.Compiler;
        /**
         * optimize namespace
         */
        optimize: Optimize;
        /**
         * dependencies namespace
         */
        dependencies: Dependencies;
        /**
         * Replace resources that matches resourceRegExp with newResource.
         * If newResource is relative, it is resolve relative to the previous resource.
         * If newResource is a function, it is expected to overwrite the request attribute of the supplied object.
         */
        NormalModuleReplacementPlugin: NormalModuleReplacementPluginStatic;
        /**
         * Replaces the default resource, recursive flag or regExp generated by parsing with newContentResource,
         * newContentRecursive resp. newContextRegExp if the resource (directory) matches resourceRegExp.
         * If newContentResource is relative, it is resolve relative to the previous resource.
         * If newContentResource is a function, it is expected to overwrite the request attribute of the supplied object.
         */
        ContextReplacementPlugin: ContextReplacementPluginStatic;
        /**
         * Dont generate modules for requests matching the provided RegExp.
         */
        IgnorePlugin: IgnorePluginStatic;
        /**
         * A request for a normal module, which is resolved and built even before a require to it occurs.
         * This can boost performance. Try to profile the build first to determine clever prefetching points.
         */
        PrefetchPlugin: PrefetchPluginStatic;
        /**
         * Apply a plugin (or array of plugins) to one or more resolvers (as specified in types).
         */
        ResolverPlugin: ResolverPluginStatic;
        /**
         * Adds a banner to the top of each generated chunk.
         */
        BannerPlugin: BannerPluginStatic;
        /**
         * Define free variables. Useful for having development builds with debug logging or adding global constants.
         */
        DefinePlugin: DefinePluginStatic;
        /**
         * Automatically loaded modules.
         * Module (value) is loaded when the identifier (key) is used as free variable in a module.
         * The identifier is filled with the exports of the loaded module.
         */
        ProvidePlugin: ProvidePluginStatic;
        /**
         * Adds SourceMaps for assets.
         */
        SourceMapDevToolPlugin: SourceMapDevToolPluginStatic;
        /**
         * Adds SourceMaps for assets, but wrapped inside eval statements.
         * Much faster incremental build speed, but harder to debug.
         */
        EvalSourceMapDevToolPlugin: EvalSourceMapDevToolPluginStatic;
        /**
         * Enables Hot Module Replacement. (This requires records data if not in dev-server mode, recordsPath)
         * Generates Hot Update Chunks of each chunk in the records.
         * It also enables the API and makes __webpack_hash__ available in the bundle.
         */
        HotModuleReplacementPlugin: HotModuleReplacementPluginStatic;
        /**
         * Adds useful free vars to the bundle.
         */
        ExtendedAPIPlugin: ExtendedAPIPluginStatic;
        /**
         * When there are errors while compiling this plugin skips the emitting phase (and recording phase),
         * so there are no assets emitted that include errors. The emitted flag in the stats is false for all assets.
         */
        NoEmitOnErrorsPlugin: NoEmitOnErrorsPluginStatic;
        /**
         * Alias for NoEmitOnErrorsPlugin
         * @deprecated
         */
        NoErrorsPlugin: NoEmitOnErrorsPluginStatic;
        /**
         * Does not watch specified files matching provided paths or RegExps.
         */
        WatchIgnorePlugin: WatchIgnorePluginStatic;
        /**
         * Uses the module name as the module id inside the bundle, instead of a number.
         * Helps with debugging, but increases bundle size.
         */
        NamedModulesPlugin: NamedModulesPluginStatic;
        /**
         * Some loaders need context information and read them from the configuration.
         * This need to be passed via loader options in the long-term. See loader documentation for relevant options.
         * To keep compatibility with old loaders, these options can be passed via this plugin.
         */
        LoaderOptionsPlugin: LoaderOptionsPluginStatic;
    }

    interface Optimize {
        /**
         * Search for equal or similar files and deduplicate them in the output.
         * This comes with some overhead for the entry chunk, but can reduce file size effectively.
         * This is experimental and may crash, because of some missing implementations. (Report an issue)
         */
        DedupePlugin: optimize.DedupePluginStatic;
        /**
         * Limit the chunk count to a defined value. Chunks are merged until it fits.
         */
        LimitChunkCountPlugin: optimize.LimitChunkCountPluginStatic;
        /**
         * Merge small chunks that are lower than this min size (in chars). Size is approximated.
         */
        MinChunkSizePlugin: optimize.MinChunkSizePluginStatic;
        /**
         * Assign the module and chunk ids by occurrence count. Ids that are used often get lower (shorter) ids.
         * This make ids predictable, reduces to total file size and is recommended.
         */
        // TODO: This is a typo, and will be removed in Webpack 2.
        OccurenceOrderPlugin: optimize.OccurenceOrderPluginStatic;
        OccurrenceOrderPlugin: optimize.OccurenceOrderPluginStatic;
        /**
         * Minimize all JavaScript output of chunks. Loaders are switched into minimizing mode.
         * You can pass an object containing UglifyJs options.
         */
        UglifyJsPlugin: optimize.UglifyJsPluginStatic;
        CommonsChunkPlugin: optimize.CommonsChunkPluginStatic;
        /**
         * A plugin for a more aggressive chunk merging strategy.
         * Even similar chunks are merged if the total size is reduced enough.
         * As an option modules that are not common in these chunks can be moved up the chunk tree to the parents.
         */
        AggressiveMergingPlugin: optimize.AggressiveMergingPluginStatic;
    }

    interface Dependencies {
        /**
         * Support Labeled Modules.
         */
        LabeledModulesPlugin: dependencies.LabeledModulesPluginStatic;
    }

    interface DirectoryDescriptionFilePluginStatic {
        new (file: string, files: string[]): Plugin;
    }

    interface NormalModuleReplacementPluginStatic {
        new (resourceRegExp: any, newResource: any): Plugin;
    }

    interface ContextReplacementPluginStatic {
        new (resourceRegExp: any, newContentResource?: any, newContentRecursive?: any, newContentRegExp?: any): Plugin;
    }

    interface IgnorePluginStatic {
        new (requestRegExp: any, contextRegExp?: any): Plugin;
    }

    interface PrefetchPluginStatic {
        // tslint:disable-next-line:unified-signatures
        new (context: any, request: any): Plugin;
        new (request: any): Plugin;
    }

    interface ResolverPluginStatic {
        new (plugins: Plugin[], files?: string[]): Plugin;
        DirectoryDescriptionFilePlugin: DirectoryDescriptionFilePluginStatic;
        /**
         * This plugin will append a path to the module directory to find a match,
         * which can be useful if you have a module which has an incorrect main entry in its package.json/bower.json etc (e.g. "main": "Gruntfile.js").
         * You can use this plugin as a special case to load the correct file for this module. Example:
         */
        FileAppendPlugin: FileAppendPluginStatic;
    }

    interface FileAppendPluginStatic {
        new (files: string[]): Plugin;
    }

    interface BannerPluginStatic {
        new (banner: any, options: any): Plugin;
    }

    interface DefinePluginStatic {
        new (definitions: {[key: string]: any}): Plugin;
    }

    interface ProvidePluginStatic {
        new (definitions: {[key: string]: any}): Plugin;
    }

    interface SourceMapDevToolPluginStatic {
        // if string | false | null, maps to the filename option
        new (options?: string | false | null | SourceMapDevToolPluginOptions): Plugin;
    }

    interface SourceMapDevToolPluginOptions {
        // output filename pattern (false/null to append)
        filename?: string | false | null;
        // source map comment pattern (false to not append)
        append?: false | string;
        // template for the module filename inside the source map
        moduleFilenameTemplate?: string;
        // fallback used when the moduleFilenameTemplate produces a collision
        fallbackModuleFilenameTemplate?: string;
        // test/include/exclude files
        test?: Condition | Condition[];
        include?: Condition | Condition[];
        exclude?: Condition | Condition[];
        // whether to include the footer comment with source information
        noSources?: boolean;
        // the source map sourceRoot ("The URL root from which all sources are relative.")
        sourceRoot?: string | null;
        // whether to generate per-module source map
        module?: boolean;
        // whether to include column information in the source map
        columns?: boolean;
        // whether to preserve line numbers between source and source map
        lineToLine?: boolean | {
            test?: Condition | Condition[];
            include?: Condition | Condition[];
            exclude?: Condition | Condition[];
        };
    }

    interface EvalSourceMapDevToolPluginStatic {
        // if string | false, maps to the append option
        new (options?: string | false | EvalSourceMapDevToolPluginOptions): Plugin;
    }

    interface EvalSourceMapDevToolPluginOptions {
        append?: false | string;
        moduleFilenameTemplate?: string;
        sourceRoot?: string;
        module?: boolean;
        columns?: boolean;
        lineToLine?: boolean | {
            test?: Condition | Condition[];
            include?: Condition | Condition[];
            exclude?: Condition | Condition[];
        };
    }

    interface HotModuleReplacementPluginStatic {
        new (options?: any): Plugin;
    }

    interface ExtendedAPIPluginStatic {
        new (): Plugin;
    }

    interface NoEmitOnErrorsPluginStatic {
        new (): Plugin;
    }

    interface WatchIgnorePluginStatic {
        new (paths: RegExp[]): Plugin;
    }

    interface NamedModulesPluginStatic {
        new (): Plugin;
    }

    interface LoaderOptionsPluginStatic {
        new (options: any): Plugin;
    }

    namespace loader {

        interface Loader extends Function {
            (this: LoaderContext, source: string | Buffer, sourceMap: string | Buffer): string | Buffer | void | undefined;

            /**
             * The order of chained loaders are always called from right to left.
             * But, in some cases, loaders do not care about the results of the previous loader or the resource.
             * They only care for metadata. The pitch method on the loaders is called from left to right before the loaders are called (from right to left).
             * If a loader delivers a result in the pitch method the process turns around and skips the remaining loaders,
             * continuing with the calls to the more left loaders. data can be passed between pitch and normal call.
             * @param remainingRequest
             * @param precedingRequest
             * @param data
             */
            pitch?(remainingRequest: string, precedingRequest: string, data: any): any | undefined;

            /**
             * By default, the resource file is treated as utf-8 string and passed as String to the loader.
             * By setting raw to true the loader is passed the raw Buffer.
             * Every loader is allowed to deliver its result as String or as Buffer.
             * The compiler converts them between loaders.
             */
            raw?: boolean;
        }

        type loaderCallback = (err: Error | undefined | null, content?: string | Buffer, sourceMap?: string | Buffer) => void;

        interface LoaderContext {
            /**
             * Loader API version. Currently 2.
             * This is useful for providing backwards compatibility.
             * Using the version you can specify custom logic or fallbacks for breaking changes.
             */
            version: string;


            /**
             *  The directory of the module. Can be used as context for resolving other stuff.
             *  In the example: /abc because resource.js is in this directory
             */
            context: string;


            /**
             * The resolved request string.
             * In the example: "/abc/loader1.js?xyz!/abc/node_modules/loader2/index.js!/abc/resource.js?rrr"
             */
            request: string;


            /**
             *  A string or any object. The query of the request for the current loader.
             */
            query: any;


            /**
             * A data object shared between the pitch and the normal phase.
             */
            data?: any;


            callback: loaderCallback | void;


            /**
             * Make this loader async.
             */
            async(): loaderCallback | undefined;

            /**
             *  Make this loader result cacheable. By default it's not cacheable.
             *  A cacheable loader must have a deterministic result, when inputs and dependencies haven't changed.
             *  This means the loader shouldn't have other dependencies than specified with this.addDependency.
             *  Most loaders are deterministic and cacheable.
             */
            cacheable(flag?: boolean): void;

            /**
             * loaders = [{request: string, path: string, query: string, module: function}]
             * An array of all the loaders. It is writeable in the pitch phase.
             * In the example:
             * [
             *   { request: "/abc/loader1.js?xyz",
         *     path: "/abc/loader1.js",
         *     query: "?xyz",
         *     module: [Function]
         *   },
             *   { request: "/abc/node_modules/loader2/index.js",
         *     path: "/abc/node_modules/loader2/index.js",
         *     query: "",
         *     module: [Function]
         *   }
             *]
             */
            loaders: any[];

            /**
             * The index in the loaders array of the current loader.
             * In the example: in loader1: 0, in loader2: 1
             */
            loaderIndex: number;

            /**
             * The resource part of the request, including query.
             * In the example: "/abc/resource.js?rrr"
             */
            resource: string;

            /**
             * The resource file.
             * In the example: "/abc/resource.js"
             */
            resourcePath: string

            /**
             * The query of the resource.
             * In the example: "?rrr"
             */
            resourceQuery: string;

            /**
             * Emit a warning.
             * @param message
             */
            emitWarning(message: string): void;

            /**
             * Emit a error.
             * @param message
             */
            emitError(message: string): void;

            /**
             * Execute some code fragment like a module.
             *
             * Don't use require(this.resourcePath), use this function to make loaders chainable!
             *
             * @param code
             * @param filename
             */
            exec(code: string, filename: string): any;


            /**
             * Resolve a request like a require expression.
             * @param context
             * @param request
             * @param callback
             */
            resolve(context: string, request: string, callback: (err: Error, result: string) => void): any

            /**
             * Resolve a request like a require expression.
             * @param context
             * @param request
             */
            resolveSync(context: string, request: string): string


            /**
             * Adds a file as dependency of the loader result in order to make them watchable.
             * For example, html-loader uses this technique as it finds src and src-set attributes.
             * Then, it sets the url's for those attributes as dependencies of the html file that is parsed.
             * @param file
             */
            addDependency(file: string): void;

            /**
             * Adds a file as dependency of the loader result in order to make them watchable.
             * For example, html-loader uses this technique as it finds src and src-set attributes.
             * Then, it sets the url's for those attributes as dependencies of the html file that is parsed.
             * @param file
             */
            dependency(file: string): void;

            /**
             * Add a directory as dependency of the loader result.
             * @param directory
             */
            addContextDependency(directory: string): void

            /**
             * Remove all dependencies of the loader result. Even initial dependencies and these of other loaders. Consider using pitch.
             */
            clearDependencies(): void;


            /**
             * Pass values to the next loader.
             * If you know what your result exports if executed as module, set this value here (as a only element array).
             */
            value: any;

            /**
             * Passed from the last loader.
             * If you would execute the input argument as module, consider reading this variable for a shortcut (for performance).
             */
            inputValue: any;

            /**
             * The options passed to the Compiler.
             */
            options: any;

            /**
             * A boolean flag. It is set when in debug mode.
             */
            debug: boolean;

            /**
             * Should the result be minimized.
             */
            minimize: boolean;

            /**
             * Should a SourceMap be generated.
             */
            sourceMap: boolean;


            /**
             * Target of compilation. Passed from configuration options.
             * Example values: "web", "node"
             */
            target: 'web' | 'node' | string;

            /**
             * This boolean is set to true when this is compiled by webpack.
             *
             * Loaders were originally designed to also work as Babel transforms.
             * Therefore if you write a loader that works for both, you can use this property to know if
             * there is access to additional loaderContext and webpack features.
             */
            webpack: boolean;


            /**
             * Emit a file. This is webpack-specific.
             * @param name
             * @param content
             * @param sourceMap
             */
            emitFile(name: string, content: Buffer|String, sourceMap: any): void


            /**
             * Access to the compilation's inputFileSystem property.
             */
            fs: any;

            /**
             * Hacky access to the Compilation object of webpack.
             */
            _compilation: any;

            /**
             * Hacky access to the Compiler object of webpack.
             */
            _compiler: compiler.Compiler;


            /**
             * Hacky access to the Module object being loaded.
             */
            _module: any;
        }
    }

    namespace optimize {
        interface DedupePluginStatic {
            new (): Plugin;
        }
        interface LimitChunkCountPluginStatic {
            new (options: any): Plugin;
        }
        interface MinChunkSizePluginStatic {
            new (options: any): Plugin;
        }
        interface OccurenceOrderPluginStatic {
            new (preferEntry: boolean): Plugin;
        }
        interface UglifyJsPluginStatic {
            new (options?: UglifyPluginOptions): Plugin;
        }
        interface CommonsChunkPluginStatic {
            new (chunkName: string, filenames?: string | string[]): Plugin;
            new (options?: any): Plugin;
        }
        interface AggressiveMergingPluginStatic {
            new (options: any): Plugin;
        }
    }

    namespace dependencies {
        interface LabeledModulesPluginStatic {
            new (): Plugin;
        }
    }

    namespace compiler {
        interface Compiler {
            /** Builds the bundle(s). */
            run(callback: CompilerCallback): void;
            /**
             * Builds the bundle(s) then starts the watcher, which rebuilds bundles whenever their source files change.
             * Returns a Watching instance. Note: since this will automatically run an initial build, so you only need to run watch (and not run).
             */
            watch(watchOptions: WatchOptions, handler: CompilerCallback): Watching;
            //TODO: below are some of the undocumented properties. needs typings
            outputFileSystem: any;
            name: string;
            options: Configuration;
        }

        interface Watching {
            close(callback: () => void): void;
        }

        interface WatchOptions {
            /** After a change the watcher waits that time (in milliseconds) for more changes. Default: 300. */
            aggregateTimeout?: number;
            /** For some systems, watching many file systems can result in a lot of CPU or memory usage. It is possible to exclude a huge folder like node_modules. It is also possible to use anymatch patterns. */
            ignored?: RegExp | string;
            /** The watcher uses polling instead of native watchers. true uses the default interval, a number specifies a interval in milliseconds. Default: undefined (automatic). */
            poll?: number | boolean;
        }

        interface Stats {
            /** Returns true if there were errors while compiling */
            hasErrors(): boolean;
            /** Returns true if there were warnings while compiling. */
            hasWarnings(): boolean;
            /** Return information as json object */
            toJson(options?: StatsOptions): any; //TODO: type this
            /** Returns a formatted string of the result. */
            toString(options?: StatsToStringOptions): string;
        }

        interface StatsOptions {
            /** Add asset Information */
            assets?: boolean;
            /** Sort assets by a field */
            assetsSort?: string;
            /** Add information about cached (not built) modules */
            cached?: boolean;
            /** Add children information */
            children?: boolean;
            /** Add chunk information (setting this to `false` allows for a less verbose output) */
            chunks?: boolean;
            /** Add built modules information to chunk information */
            chunkModules?: boolean;
            /** Add the origins of chunks and chunk merging info */
            chunkOrigins?: boolean;
            /** Sort the chunks by a field */
            chunksSort?: string;
            /** Context directory for request shortening */
            context?: string;
            /** Add errors */
            errors?: boolean;
            /** Add details to errors (like resolving log) */
            errorDetails?: boolean;
            /** Add the hash of the compilation */
            hash?: boolean;
            /** Add built modules information */
            modules?: boolean;
            /** Sort the modules by a field */
            modulesSort?: string;
            /** Add public path information */
            publicPath?: boolean;
            /** Add information about the reasons why modules are included */
            reasons?: boolean;
            /** Add the source code of modules */
            source?: boolean;
            /** Add timing information */
            timings?: boolean;
            /** Add webpack version information */
            version?: boolean;
            /** Add warnings */
            warnings?: boolean;
        }

        interface StatsToStringOptions extends StatsOptions {
            /** With console colors */
            colors?: boolean;
        }

        type CompilerCallback = (err: Error, stats: Stats) => void;
    }

    interface PerformanceOptions {
        /**
         * Turns hints on/off. In addition, tells webpack to throw either an error or a warning when hints are found. This property is set to "warning" by default.
         */
        hints?: boolean | 'error' | 'warning';
        /**
         * An entrypoint represents all assets that would be utilized during initial load time for a specific entry. This option controls when webpack should emit performance hints based on the maximum entrypoint size. The default value is 250000 (bytes).
         */
        maxEntrypointSize?: number;
        /**
         * An asset is any emitted file from webpack. This option controls when webpack emits a performance hint based on individual asset size. The default value is 250000 (bytes).
         */
        maxAssetSize?: number;
        /**
         * This property allows webpack to control what files are used to calculate performance hints.
         */
        assetFilter?: (assetFilename: string) => boolean;
    }
}

var webpack: webpack.Webpack;

//export default webpack;
export = webpack;
}
/// <reference path="modules/bcrypt-nodejs/index.d.ts" />
/// <reference path="modules/helmet/index.d.ts" />
/// <reference path="modules/mysql/index.d.ts" />
/// <reference path="modules/source-map/index.d.ts" />
/// <reference path="modules/tapable/index.d.ts" />
/// <reference path="modules/uglify-js/index.d.ts" />
/// <reference path="modules/webpack/index.d.ts" />
